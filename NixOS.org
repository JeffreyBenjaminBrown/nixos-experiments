* user ID problems
** changing user ID in NixOS is complicated
*** because it won't let you change the ID of an existing user
at least not by modifying configuration.nix.
(It'll compile the changes,
and announce that it won't apply that change.)
*** so do this
Log in as root, not self.
Remove all users from configuration.nix
Rebuild and switch.
Add user again, this time with the ID specified.
Rebuild and switch.
** to chmod back to 644 (normal): omit folders
Otherwise the folder contents cannot be read without sudo.
sudo find . -type f -print0 | xargs -0 chmod 644
sudo find . -type d -print0 | xargs -0 chmod 744

find . -type d -print0 | xargs -0 chown 1001
find . -type f -print0 | xargs -0 chown 1001
** TODO what is the default group in Kubuntu?
I have to change not only the id (to jeff=1000),
but the default group, too.
*** demo code
users.groups.students.gid = 1000;  # TODO: Enable.
                                   # for congruence with KUbuntu system
** the Ubuntu-NixOS user ID problem
On my KUbuntu system, "jeff" has default uid 1000;
on NixOS it's 1001. This creates permissions problems.
* TODO resume review at pill 7.5
* TODO learn to write Nix expressions
** stdenv.mkDerivation:
  https://nixos.org/nixos/nix-pills/fundamentals-of-stdenv.html
* TODO Nix pills
** Ch 4: the language
*** identifiers can include "-"
So "a-b" reads as a symbol,
whereas "a - b" reads as a minus b.
*** inherit
  inherit x y z;
  inherit (src-set) a b c;
is equivalent to
  x = x; y = y; z = z;
  a = src-set.a; b = src-set.b; c = src-set.c;
*** strings can be delimited by 4 ' symbols
"a" is the same as ''a''.
Useful if a string includes the " symbol.
*** lists are space-separated and can mix types
*** "set" = "attribute set" = a map in Haskell
**** use . to access attributes
**** `rec` is a special kind whose elements can refer to each other
*** "with" brings a set's values into scope
nix-repl> longName = { a = 3; b = 4; }

nix-repl> longName.a + (with longName; a + b)
10
**** PITFALL: does not shadow
nix-repl> a = {a = 3; b = 4; }

nix-repl> with longName; a + b
error: cannot coerce a set to a string, at (string):1:16

That's because it thinks the a in a + b is the set, not the value.
** Ch 5: functions and imports
*** functions
**** pattern matching over a set in a function argument
 These are equivalent:

 nix-repl> mul = s: s.a*s.b
 nix-repl> mul { a = 3; b = 4; }
 12

 nix-repl> mul = { a, b }: a*b
 nix-repl> mul { a = 3; b = 4; }
 12
**** allow unmentioned fields with an ellipsis
 nix-repl> mul = { a, b, ... }: a*b
 nix-repl> mul { a = 3; b = 4; c = 2; }
**** define default fields with "?"
 nix-repl> mul = { a, b ? 2 }: a*b
 nix-repl> mul { a = 3; }
 6
*** "import" is just substitution
If the following files have the following content:
  a.nix   : 3
  b.nix   : 4
  mul.nix : a: b: a*b
then you can do this:
  nix-repl> a = import ./a.nix
  nix-repl> b = import ./b.nix
  nix-repl> mul = import ./mul.nix
  nix-repl> mul a b
  12
** Ch 6: "our first derivation":
https://nixos.org/nixos/nix-pills/our-first-derivation.html
*** nix repl
is nice for testing stuff.
It starts empty, but knowing things like builtins.currentTime
:l <nixpkgs> loads all those packages.
*** to build outside the nix repl
run this from bash:
  nix-store -r /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv
That assumes the .drv file exists
(and so far I only know how to create it from the nix repl).
*** PITFALL: instatiate = evaluate /= realize = build
At the nix repl, if we enter this:
  d = derivation { name = "biggles"; system = "mysystem"; builder = "mybuilder"; }

it now knows what d is. But building it is a separate step:
  :b d
*** evaluating a derivation creates a .drv file in /nix/store
In the Nix repl:

  nix-repl> d = derivation { name = "x"; builder = "y"; system = builtins.currentSystem; }

  nix-repl> d
  «derivation /nix/store/7r40h4gj6rsaw6xnsq7vj128dpiawa94-x.drv»

Then, outside of it:
  [jeff@jbb-dell:~/nix/temp]$ nix show-derivation /nix/store/7r40h4gj6rs
  aw6xnsq7vj128dpiawa94-x.drv
  {
    "/nix/store/7r40h4gj6rsaw6xnsq7vj128dpiawa94-x.drv": {
      "outputs": {
        "out": {
          "path": "/nix/store/f4z943mkd9zkhcjk2mwy3p9g14qf6wvb-x"
        }
      },
      "inputSrcs": [],
      "inputDrvs": {},
      "platform": "x86_64-linux",
      "builder": "y",
      "args": [],
      "env": {
        "builder": "y",
        "name": "x",
        "out": "/nix/store/f4z943mkd9zkhcjk2mwy3p9g14qf6wvb-x",
        "system": "x86_64-linux"
      }
    }
  }
*** PITFALL: sometimes, sets can be converted to strings
Namely, if they contain an "outPath" field.
Note that evaluating a derivation at the repl shows its .drv path,
not its outPath:
  nix-repl> coreutils
  «derivation /nix/store/1zcs1y4n27lqs0gw4v038i303pb89rw6-coreutils-8.21.drv»
  nix-repl> builtins.toString coreutils
  "/nix/store/8w4cbiy7wqvaqsnsnb3zvabq1cp2zhyz-coreutils-8.21"
** Ch 7: (our first) "working derivation"
https://nixos.org/nixos/nix-pills/working-derivation.html
*** PITFALL: Relative paths in strings are treated differently
From a string, Nix will parse the path relative to the temp directory it makes for building.
Outside of a string, Nix parses it relative to the current directory.
*** a minimal build
Make a file called "builder.sh" containing
  declare -xp
  echo foo > $out
Then enter nix repl, and evaluate
  :l <nixpkgs> # for access to bash
  d = derivation { name = "foo"; builder = "${bash}/bin/bash"; args = [ ./builder.sh ]; system = builtins.currentSystem; }
  :b d
** Ch 8: Generic Builders
https://nixos.org/nixos/nix-pills/generic-builders.html
* TODO ask: how does sc3-plugins know where the supercollider source is?
The Nix expression I found for sc3-plugins does not seem to refer to the source that would have been installed first for supercollider. How? Is the fact that supercollider is among sc3-plugins's buildInputs somehow sufficient?

nixos.org publishes a [Nix expression for installing sc3](https://github.com/NixOS/nixpkgs/blob/bd6ba87381ef6274a830253b60e481209d4d7c7d/pkgs/development/interpreters/supercollider/default.nix#L35) (SuperCollider version 3.9.3).

Elsewhere, someone published a GitHub gist titled [Nix package definition for sc3-plugins](https://gist.github.com/gosub/a42e265ec38d9df203d6).

SC3-plugins installation instructions
https://github.com/supercollider/sc3-plugins
The latest stable release of that is 3.9.1:
https://github.com/supercollider/sc3-plugins/releases

How to build SC from source:
https://github.com/supercollider/supercollider/blob/develop/README_LINUX.md
* reading the NixOS manual
** getting started (installing, mostly)
*** move everything critical to an available USB
  NixOS.org (this file)
  installs/how-to-reinstall-linux.org
  borg-backup*.sh
*** know the USBs
**** white one has Kubuntu 18.04, just in case
**** slate = "Patriot 14.8G" is empty
**** shuttle
**** blue one = "PATRIOT" is 128G and empty
*** downloading it
**** the white USB (1.8 GB) is big enough
***** even for the graphical live booter
**** start with the live booter
***** use the 128GB stick as a store
**** will eventually need the unstable OS
***** because it works with JACK
*** configuring it post-build
**** git problems
  Sometimes repos need to be re-cloned or chmodded.
    Maybe this is because I borg-extracted as root?
    But strangely, the hode repo did not need this.
*** use MusNix
  https://github.com/musnix/musnix
  Alas, cannot install from this; must switch to it.
*** installing stuff (ch 3)
**** basically
***** modify /etc/nixos/configuration.nix
***** then run nixos-rebuild test
****** this tries it without making it the default
***** if it works, run nixos-rebuild switch
**** can add it to Grub menu
*** ch 4: upgrading Nix
**** is via channels, but voluntary
**** PITFALL: needs root to matter?
**** nixos-rebuild switch --upgrade
**** PITFALL: can't always rollback Nix channels
***** "Warning: It is generally safe to switch back and forth between channels. The only exception is that a newer NixOS may also have a newer Nix version, which may involve an upgrade of Nix’s database schema. This cannot be undone easily, so in that case you will not be able to go back to your original channel."
**** can be automatic, periodic
** tricky | hard to look up
*** ch 5: configuration syntax
**** nix calls maps "sets"
**** package is a type
**** values are expressions, but attributes are not
  Let statements are valid wherever expression are valid.
**** merge sets with //
**** let, functions, map
**** string splice with $
  For instance, this function splices the string "name" into another:
  makeVirtualHost = name:
    { hostName = name;
      documentRoot = "/sites/${name}";
      adminAddr = "alice@example.org";
    };
**** options can be merged from multiple files
  when it makes sense -- e.g. lists, not strings
**** `config` arg: the complete merged configuration
**** discovering attribute values
 Helpful for complicated configurations, where options are getting merged from multiple files.
***** command line: nixos-option <option>
***** or use the repl: "nix repl <package>"
**** lambda expressions
 map (x: x.hostName) config.services.httpd.virtualHosts
**** select attributes with (.)
 { x = 1; y = 2; }.x == 1
***** can include a default
 ({ x = 1; y = 2; }.z or 3) == 4
**** add attributes to a scope
 (with pkgs.lib; head [ 1 2 3 ]) == 1
**** functions
***** are called Python-style
 name(argument)
***** PITFALL: bind after list construction
 so, for instance, you'll need to wrap applied functions in parens if they are expressions in lists:
   environment.systemPackages = [ (pkgs.emacs.override { gtk = pkgs.gtk3; }) ];
***** are always of one argument (which could be a set)x
***** can have default values
 { x, y ? "bar" }: x + y
***** can accept irrelevant values
 This function requires x and y, and ignroes anything else:
 { x, y, ... }: x + y
***** can bind the entire set argument to a name
 { x, y } @ args: x + y
**** import <file>
 "Load and return Nix expression in given file"
*** ch 6: package management
**** packages can have optional settings
 nixpkgs.config.firefox.enableGoogleTalkPlugin = true;
 PITFALL: this kind of option is not queriable
**** customizing packages
***** package dependencies can be overridden
  environment.systemPackages = [ (pkgs.emacs.override { gtk = pkgs.gtk3; }) ];
***** package attributes can be overridden
 e.g. to change the source code
 use overrideAttrs
***** customized packages do not break things that depend on the uncustommized one
 Nix will instead keep two versions of the package.
 But that too can be changed, with a "global override".
* adding custom Nix expressions
https://nixos.org/nix/manual/#chap-writing-nix-expressions
** inherit x y ...
has the same effect as writinng "x = x; y = y; ...".
It's used for handing an argument unchanged from the Nix expression to the builder.
** a Nix expression calls a build script
*** PITFALL: if the builder attribute is omitted
then it uses mkDerivation, which
"does a configure; make; make install, in essence".
** build script syntax
It starts by "clearing the environment" | "using a standard environment". That corresponds to this line:
  source $stdenv/setup

It might need to augment PATH with arguments, ala
  PATH=$perl/bin:$PATH

It uses the automatically generated $out argument to determine where to build, ala
  ./configure --prefix=$out

Beyond that it's just normal bash.
** "compose" the the package
*** why this step is called composition
It consists of adding a line (or a few) to all-packages.nix.
The Nix expression has no idea what its arguments are.
This step is where they get connected.
*** see Nix manual sec. 14.3: Arguments and Variables
*** use either rec or callPackage
**** callPackage is simpler
If the arguments to use are equal to their names,use it.
See all-packages.nix (in the nixpkgs repo) for examples.
**** rec is more flexible
And interestingly, seldom used in all-packages.nix
See Nix manual section 14.3 for an example.
*** PITFALL: import statements do not extend all the way to default.nix
but rather to its superdirectory
** build and test
From the top of the newly-modified nixpkgs repo,
call
  nix-build -A pkg
where `pkg` is the new thing.

This will create a symlink called "result".
Next test the new command by running, say,
  ./result/bin/hello
* configuring Emacs
** guidance
https://www.reddit.com/r/NixOS/comments/ad6miw/building_an_emacs_configuration_using_nixpkg/
https://nixos.org/nixpkgs/manual/#sec-emacs
** overlays -- better than one config.nix blob?
https://www.reddit.com/r/NixOS/comments/9swtg3/do_you_put_all_packages_you_install_into/e8s4u9f/
** some peoples' configs
https://github.com/tazjin/nixos-config
https://github.com/telent/config-nixpkgs
* ambitious
** TODO put NextCloud on the Rapsberry
 chapter 15 in NixOS manual.
 There's also TaskServer, for todo lists,
   GitLab,
